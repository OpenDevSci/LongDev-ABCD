import{MessageChannel as U,isMainThread as D}from"worker_threads";import{a as I,n as T,s as A}from"../node-features-53cd96d9.mjs";import J from"module";import{installSourceMapSupport as R}from"../source-map.mjs";import l from"path";import{fileURLToPath as y,pathToFileURL as x}from"url";import{t as S,a as k}from"../index-9eae64fa.mjs";import{r as W}from"../resolve-ts-path-a8cb04a4.mjs";import{parseTsconfig as b,getTsconfig as $,createFilesMatcher as C,createPathsMatcher as K}from"get-tsconfig";import N from"fs";import"source-map-support";import"esbuild";import"crypto";import"os";const q=()=>{const{port1:t,port2:s}=new U;R(t),process.send&&t.addListener("message",r=>{r.type==="dependency"&&process.send(r)}),t.unref(),J.register("./index.mjs",{parentURL:import.meta.url,data:{port:s},transferList:[s]})},m=new Map;async function B(t){if(m.has(t))return m.get(t);if(!await N.promises.access(t).then(()=>!0,()=>!1)){m.set(t,void 0);return}const r=await N.promises.readFile(t,"utf8");try{const e=JSON.parse(r);return m.set(t,e),e}catch{throw new Error(`Error parsing: ${t}`)}}async function G(t){let s=new URL("package.json",t);for(;!s.pathname.endsWith("/node_modules/package.json");){const r=y(s),e=await B(r);if(e)return e;const o=s;if(s=new URL("../package.json",s),s.pathname===o.pathname)break}}async function H(t){var s;const r=await G(t);return(s=r==null?void 0:r.type)!=null?s:"commonjs"}const f=R(),d=process.env.ESBK_TSCONFIG_PATH?{path:l.resolve(process.env.ESBK_TSCONFIG_PATH),config:b(process.env.ESBK_TSCONFIG_PATH)}:$(),O=d&&C(d),M=d&&K(d),w="file://",u=/\.([cm]?ts|[tj]sx)($|\?)/,_=/\.json(?:$|\?)/,Q=t=>{const s=l.extname(t);if(s===".json")return"json";if(s===".mjs"||s===".mts")return"module";if(s===".cjs"||s===".cts")return"commonjs"},j=t=>{const s=Q(t);if(s)return s;if(u.test(t))return H(t)},v=/\/(?:$|\?)/;let h,g=process.send?process.send.bind(process):void 0;const X=async t=>{if(!t)throw new Error(`tsx must be loaded with --import instead of --loader
The --loader flag was deprecated in Node v20.6.0`);const{port:s}=t;h=s,g=s.postMessage.bind(s)},z=({port:t})=>(h=t,g=t.postMessage.bind(t),`
	const require = getBuiltin('module').createRequire("${import.meta.url}");
	require('tsx/source-map').installSourceMapSupport(port);
	if (process.send) {
		port.addListener('message', (message) => {
			if (message.type === 'dependency') {
				process.send(message);
			}
		});
	}
	port.unref(); // Allows process to exit without waiting for port to close
	`),E=async(t,s,r)=>{const e=await t(s,r);return!e.format&&e.url.startsWith(w)&&(e.format=await j(e.url)),e},V=[".js",".json",".ts",".tsx",".jsx"];async function P(t,s,r){const[e,o]=t.split("?");let i;for(const a of V)try{return await E(r,e+a+(o?`?${o}`:""),s)}catch(n){if(i===void 0&&n instanceof Error){const{message:c}=n;n.message=n.message.replace(`${a}'`,"'"),n.stack=n.stack.replace(c,n.message),i=n}}throw i}async function F(t,s,r){const e=v.test(t),o=e?"index":"/index",[i,a]=t.split("?");try{return await P(i+o+(a?`?${a}`:""),s,r)}catch(n){if(!e)try{return await P(t,s,r)}catch{}const c=n,{message:p}=c;throw c.message=c.message.replace(`${o.replace("/",l.sep)}'`,"'"),c.stack=c.stack.replace(p,c.message),c}}const Y=/^\.{1,2}\//,L=async function(t,s,r,e){var o;if(!I&&t.startsWith("node:")&&(t=t.slice(5)),v.test(t))return await F(t,s,r);const i=t.startsWith(w)||Y.test(t);if(M&&!i&&!((o=s.parentURL)!=null&&o.includes("/node_modules/"))){const a=M(t);for(const n of a)try{return await L(x(n).toString(),s,r)}catch{}}if(u.test(s.parentURL)){const a=W(t);if(a)for(const n of a)try{return await E(r,n,s)}catch(c){const{code:p}=c;if(p!=="ERR_MODULE_NOT_FOUND"&&p!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw c}}try{return await E(r,t,s)}catch(a){if(a instanceof Error&&!e){const{code:n}=a;if(n==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await F(t,s,r)}catch(c){if(c.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw c}if(n==="ERR_MODULE_NOT_FOUND")try{return await P(t,s,r)}catch{}}throw a}},Z=async function(t,s,r){var e;g&&g({type:"dependency",path:t}),_.test(t)&&(s.importAssertions||(s.importAssertions={}),s.importAssertions.type="json");const o=await r(t,s);if(!o.source)return o;const i=t.startsWith("file://")?y(t):t,a=o.source.toString();if(o.format==="json"||u.test(t)){const n=await S(a,i,{tsconfigRaw:(e=O)==null?void 0:e(i)});return{format:"module",source:f(n,t,h)}}if(o.format==="module"){const n=k(i,a);n&&(o.source=f(n,t,h))}return o},tt=async function(t,s,r){if(_.test(t))return{format:"module"};try{return await r(t,s,r)}catch(e){if(e.code==="ERR_UNKNOWN_FILE_EXTENSION"&&t.startsWith(w)){const o=await j(t);if(o)return{format:o}}throw e}},st=async function(t,s,r){var e;const{url:o}=s,i=o.startsWith("file://")?y(o):o;if(process.send&&process.send({type:"dependency",path:o}),_.test(o)||u.test(o)){const n=await S(t.toString(),i,{tsconfigRaw:(e=O)==null?void 0:e(i)});return{source:f(n,o)}}const a=await r(t,s,r);if(s.format==="module"){const n=k(i,a.source.toString());n&&(a.source=f(n,o))}return a},rt=T?tt:void 0,ot=T?st:void 0;A&&D&&q();export{rt as getFormat,z as globalPreload,X as initialize,Z as load,L as resolve,ot as transformSource};
